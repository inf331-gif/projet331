 PR√âSENTATION GLOBALE

Notre syst√®me reproduit un h√¥pital moderne en architecture microservices :

 H√îPITAL DIGITAL - VISION D'ENSEMBLE

                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                         ‚îÇ     üåê CLIENT   ‚îÇ
                         ‚îÇ  Navigateur /   ‚îÇ
                         ‚îÇ  Applications   ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚îÇ
                                   ‚ñº
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                         ‚îÇ   üö™ API GATEWAY‚îÇ
                         ‚îÇ     Port 8080   ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚îÇ
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚ñº             ‚ñº             ‚ñº             ‚ñº             ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ üîê AUTH ‚îÇ   ‚îÇ üè• MEDICAL ‚îÇ  ‚îÇ üë• USERS   ‚îÇ  ‚îÇ üìÑ OCR  ‚îÇ  ‚îÇ  ML / AI    ‚îÇ
    ‚îÇ Port 8001‚îÇ   ‚îÇ Port 8003 ‚îÇ  ‚îÇ Port 8006  ‚îÇ  ‚îÇ Port8005‚îÇ  ‚îÇ Port 8004   ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ             ‚îÇ             ‚îÇ             ‚îÇ             ‚îÇ
          ‚îÇ             ‚îÇ             ‚îÇ             ‚îÇ             ‚îÇ
          ‚ñº             ‚ñº             ‚ñº             ‚ñº             ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ auth_db ‚îÇ   ‚îÇ medical_db ‚îÇ  ‚îÇ users_db   ‚îÇ  ‚îÇ ocr_db  ‚îÇ  ‚îÇ ml_db       ‚îÇ
    ‚îÇ Port5432‚îÇ   ‚îÇ Port5433   ‚îÇ  ‚îÇ Port5434   ‚îÇ  ‚îÇ Port5435‚îÇ  ‚îÇ Port5436    ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                      ‚îÇ
                                      ‚ñº
                                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                ‚îÇBlockchain / ‚îÇ
                                ‚îÇ ledger_db   ‚îÇ
                                ‚îÇ Port5437    ‚îÇ
            

---

### **Page 1 : Page de Titre**

# Documentation Technique Compl√®te

## Librairies Partag√©es (`shared_libs`) pour l'Architecture Microservices du Syst√®me Hospitalier

---

### **Page 2 : Table des Mati√®res**

1.  **Introduction √† l'Architecture `shared_libs`**
    *   Philosophie et Objectifs
    *   Diagramme d'Interaction des Composants

2.  **Le C≈ìur de la S√©curit√© : `shared_libs/security`**
    *   **Classe `JWTHandler` : Le Bureau des Badges d'Acc√®s**
        *   R√¥le et Concept des JWT
        *   Analyse des M√©thodes (`create_access_token`, `verify_token`, `get_current_user`)
    *   **Classe `PasswordHasher` : Le Coffre-Fort des Mots de Passe**
        *   Principe du Hashage S√©curis√©
        *   Analyse des M√©thodes (`hash_password`, `verify_password`)
    *   **Classe `AuthMiddleware` : L'Agent de S√©curit√© √† l'Entr√©e**
        *   Le R√¥le d'un Middleware
        *   Fonctionnement D√©taill√© du `__call__`
        *   Analyse des M√©thodes (`_is_public_route`, `require_role`)
    *   **Classe `ServiceAuthenticator` : Le Courrier Interne S√©curis√©**
        *   S√©curisation de la Communication Inter-Services
        *   Analyse des M√©thodes (`verify_service_api_key`, `make_authenticated_request`)
    *   **Classe `SecurityConfig` : Le Directeur de la S√©curit√©**
        *   R√¥le d'Orchestrateur
        *   Analyse des M√©thodes (`setup_security`, `get_auth_dependency`, `get_role_dependency`)

3.  **La Bo√Æte √† Outils Universelle : `shared_libs/utils`**
    *   **Classe `APIResponse` : Le Langage Commun**
        *   Importance de la Standardisation
        *   Exemples de R√©ponses (Succ√®s, Erreur, Pagination)
    *   **Classe `DataValidator` : Le Contr√¥leur Qualit√©**
        *   Validation et Nettoyage des Donn√©es
    *   **Classe `StructuredLogger` : Le Journal de Bord Intelligent**
        *   B√©n√©fices du Logging Structur√©
    *   **Classe `ErrorHandler` : Le Service des Urgences Logiciel**
        *   Gestion Globale des Exceptions
    *   **Classe `ConfigManager` : Le Centre de Configuration**
        *   Centralisation des Param√®tres

4.  **La Fondation des Donn√©es : `shared_libs/database`**
    *   **Classe `BaseModel` : Le Plan de Construction**
        *   R√¥le et Avantages

5.  **Synth√®se et Flux de Vie d'une Requ√™te**
    *   Sch√©ma r√©capitulatif

---

### **Page 3 : Introduction √† l'Architecture `shared_libs`**

#### Philosophie et Objectifs

La biblioth√®que `shared_libs` est le fondement de notre architecture microservices. Elle a √©t√© con√ßue selon les principes **DRY (Don't Repeat Yourself)** et de **s√©paration des pr√©occupations**.

**Objectifs Cl√©s :**
1.  **Coh√©rence :** Tous les services partagent la m√™me logique pour la s√©curit√©, le logging, la gestion des erreurs et le formatage des r√©ponses.
2.  **S√©curit√© Centralis√©e :** Les m√©canismes de s√©curit√© sont d√©finis une seule fois et appliqu√©s uniform√©ment, r√©duisant la surface d'attaque.
3.  **Productivit√© Acc√©l√©r√©e :** Les d√©veloppeurs peuvent se concentrer sur la logique m√©tier sp√©cifique √† leur service sans r√©inventer la roue pour les fonctionnalit√©s transverses.
4.  **Maintenabilit√© :** Une mise √† jour de s√©curit√© ou d'un utilitaire dans `shared_libs` se propage √† tous les services.

#### Diagramme d'Interaction des Composants

Ce diagramme montre comment les principaux composants interagissent lors d'une requ√™te API.

```mermaid
graph TD
    A[Requ√™te HTTP Entrante] --> B(AuthMiddleware);
    B -- Route Publique? --> C{D√©cision};
    C -- Oui --> D[Contr√¥leur de la Route];
    C -- Non --> E(JWTHandler);
    E -- Valide le Token --> F{Token Valide?};
    F -- Oui --> D;
    F -- Non --> G[Erreur 401 Unauthorized];
    
    D -- Acc√®s aux Donn√©es --> H(BaseModel);
    D -- Logique M√©tier --> I(DataValidator);
    D -- Enregistre une Action --> J(StructuredLogger);
    D -- Erreur Inattendue --> K(ErrorHandler);
    D -- Renvoie une R√©ponse --> L(APIResponse);
    
    subgraph "shared_libs"
        B; E; H; I; J; K; L;
    end
```

---

### **Page 4 : Le C≈ìur de la S√©curit√© - `JWTHandler`**

#### Classe `JWTHandler` : Le Bureau des Badges d'Acc√®s

**R√¥le :** G√©rer l'int√©gralit√© du cycle de vie des JSON Web Tokens (JWT). C'est le composant qui cr√©e les "badges d'acc√®s" s√©curis√©s pour les utilisateurs et qui v√©rifie l'authenticit√© de ces badges √† chaque fois qu'ils sont pr√©sent√©s.

**Concept Cl√© :** L'authentification par JWT est **stateless**. Le serveur n'a pas besoin de stocker d'informations sur la session de l'utilisateur. Toutes les donn√©es n√©cessaires (ID, r√¥le, date d'expiration) sont contenues dans le token lui-m√™me, de mani√®re s√©curis√©e et infalsifiable gr√¢ce √† la signature.

#### Analyse D√©taill√©e des M√©thodes

`__init__(self)`
*   **But :** Initialise le gestionnaire avec les param√®tres de s√©curit√© essentiels.
*   **Fonctionnement :** Il charge la cl√© secr√®te, l'algorithme et les dur√©es de vie des tokens depuis les variables d'environnement (`.env`). Si aucune cl√© secr√®te n'est fournie, il en g√©n√®re une de mani√®re s√©curis√©e pour √©viter les configurations par d√©faut dangereuses.

`create_access_token(self, data: Dict) -> str`
*   **But :** Cr√©er un badge d'acc√®s (token) √† courte dur√©e de vie.
*   **Fonctionnement :**
    1.  Prend en entr√©e un dictionnaire contenant les informations de l'utilisateur (`user_id`, `email`, `role`).
    2.  Ajoute des "claims" (informations) standards :
        *   `exp` (expiration) : Calcule la date et l'heure d'expiration (ex: dans 30 minutes).
        *   `iat` (issued at) : Enregistre l'heure de cr√©ation.
    3.  Utilise la biblioth√®que `jose.jwt` pour encoder ces donn√©es avec la cl√© secr√®te et l'algorithme (HS256). Le r√©sultat est une cha√Æne de caract√®res `HEADER.PAYLOAD.SIGNATURE`.

`verify_token(self, token: str) -> Dict`
*   **But :** Valider un token.
*   **Fonctionnement :** C'est l'op√©ration inverse de la cr√©ation.
    1.  Tente de d√©coder le token en utilisant la m√™me cl√© secr√®te et le m√™me algorithme.
    2.  La biblioth√®que v√©rifie automatiquement deux choses cruciales :
        *   **La signature :** Si le payload a √©t√© modifi√©, la signature ne correspondra plus.
        *   **L'expiration :** Si la date `exp` est pass√©e, une erreur est lev√©e.
    3.  En cas d'√©chec (token invalide, expir√© ou malform√©), une `HTTPException` `401 Unauthorized` est lev√©e.

`get_current_user(self, credentials) -> TokenData`
*   **But :** C'est une **d√©pendance FastAPI**. Son r√¥le est d'√™tre utilis√© directement dans la signature des routes pour extraire, valider et transformer le token en un objet `TokenData` propre et utilisable.
*   **Fonctionnement :**
    1.  `Depends(HTTPBearer())` : FastAPI extrait automatiquement le token du header `Authorization: Bearer <token>`.
    2.  Il v√©rifie d'abord si le token est expir√© avec `is_token_expired`.
    3.  Il appelle `verify_token` pour valider et d√©coder le token.
    4.  Il extrait les informations (`user_id`, `email`, `role`) du payload d√©cod√©.
    5.  Il retourne un objet `TokenData` (un mod√®le Pydantic), ce qui permet l'autocompl√©tion et la validation de types dans le reste du code.

---

### **Page 5 : Le C≈ìur de la S√©curit√© - `PasswordHasher`**

#### Classe `PasswordHasher` : Le Coffre-Fort des Mots de Passe

**R√¥le :** Assurer que les mots de passe des utilisateurs ne sont JAMAIS stock√©s en clair. Il transforme les mots de passe en une empreinte digitale cryptographique (hash) irr√©versible.

**Principe du Hashage S√©curis√© :**
*   **Irr√©versibilit√© :** Il est math√©matiquement impossible de retrouver le mot de passe original √† partir du hash.
*   **Salage (Salting) :** L'algorithme (`bcrypt`) ajoute une cha√Æne de caract√®res al√©atoire (le "sel") au mot de passe avant de le hasher. Cons√©quence : m√™me si deux utilisateurs ont le m√™me mot de passe, leurs hashes seront compl√®tement diff√©rents. Cela prot√®ge contre les attaques par "rainbow tables".
*   **Facteur de co√ªt :** `bcrypt` est intentionnellement lent. Cela rend les attaques par force brute (qui consistent √† tester des millions de mots de passe par seconde) extr√™mement co√ªteuses et longues.

#### Analyse D√©taill√©e des M√©thodes

`__init__(self)`
*   **But :** Configurer le contexte de hashage.
*   **Fonctionnement :** Il initialise `CryptContext` avec le sch√©ma `bcrypt`. La ligne `deprecated="auto"` signifie que si √† l'avenir on d√©cide de changer d'algorithme, les anciens hashes seront automatiquement mis √† jour lors de la prochaine connexion de l'utilisateur. Il inclut un fallback vers `pbkdf2_sha256` si `bcrypt` n'est pas correctement install√©, garantissant que l'application puisse d√©marrer.

`hash_password(self, password: str) -> str`
*   **But :** Transformer un mot de passe en clair en un hash s√©curis√©.
*   **Fonctionnement :**
    1.  Il prend le mot de passe en clair.
    2.  Il le passe √† la fonction `self.pwd_context.hash()`.
    3.  Celle-ci g√©n√®re un sel al√©atoire, l'combine avec le mot de passe, et ex√©cute l'algorithme `bcrypt`.
    4.  Elle retourne une cha√Æne unique qui contient √† la fois le sel et le hash. Exemple : `$2b$12$N9qo8uLOickgx2ZMRZoMye.M...`

`verify_password(self, plain_password: str, hashed_password: str) -> bool`
*   **But :** V√©rifier si un mot de passe en clair correspond √† un hash stock√©.
*   **Fonctionnement :**
    1.  Prend le mot de passe en clair et le hash stock√©.
    2.  La fonction `self.pwd_context.verify()` est intelligente :
        *   Elle extrait le sel de la cha√Æne `hashed_password`.
        *   Elle utilise ce m√™me sel pour hasher le `plain_password`.
        *   Elle compare le r√©sultat avec le hash original.
    3.  Retourne `True` si les deux correspondent, `False` sinon.

---

### **Page 6 : Le C≈ìur de la S√©curit√© - `AuthMiddleware`**

#### Classe `AuthMiddleware` : L'Agent de S√©curit√© √† l'Entr√©e

**R√¥le :** C'est un composant de FastAPI qui s'ex√©cute **avant** chaque requ√™te. Son travail est de filtrer l'acc√®s en amont, prot√©geant ainsi l'ensemble des routes de l'application sans avoir √† ajouter manuellement une v√©rification sur chacune d'elles.

#### Fonctionnement D√©taill√©

`async def __call__(self, request: Request, call_next)`
*   **But :** C'est la m√©thode principale du middleware, ex√©cut√©e pour chaque requ√™te.
*   **Flux d'Ex√©cution :**
    1.  **√âtape 1 : V√©rification de la route publique.** Il appelle `_is_public_route(request)`. Si la route est publique (comme `/docs` ou `/auth/login`), il ne fait rien et passe simplement la main √† la suite avec `await call_next(request)`.
    2.  **√âtape 2 : R√©cup√©ration du token.** Si la route est prot√©g√©e, il tente d'extraire le token du header `Authorization` via `self.security(request)`.
    3.  **√âtape 3 : Validation de la pr√©sence.** Si aucun token n'est fourni (`credentials` est `None`), il l√®ve imm√©diatement une `HTTPException` `401`, bloquant la requ√™te.
    4.  **√âtape 4 : Validation du token.** Il utilise `self.jwt_handler.get_current_user()` pour valider le token. Cette m√©thode interne peut lever sa propre exception `401` si le token est expir√© ou invalide.
    5.  **√âtape 5 : Attachement de l'utilisateur.** Si le token est valide, les informations de l'utilisateur (`TokenData`) sont stock√©es dans `request.state.user`. Cela permet aux routes qui suivent d'acc√©der facilement √† l'identit√© de l'utilisateur qui a fait la requ√™te.
    6.  **√âtape 6 : Poursuite de la requ√™te.** Il appelle `await call_next(request)` pour laisser la requ√™te atteindre sa destination finale (le code de la route).

`_is_public_route(self, request: Request) -> bool`
*   **But :** D√©terminer si une URL doit √™tre exempt√©e de la v√©rification d'authentification.
*   **Fonctionnement :** Il compare le chemin de l'URL de la requ√™te (`request.url.path`) avec une liste pr√©d√©finie de chemins publics (`public_paths`). Il utilise `startswith` pour permettre des "wildcards" (ex: `/auth/` couvre `/auth/login`, `/auth/register`, etc.).

`require_role(self, required_roles: list)`
*   **But :** Fournir une **d√©pendance FastAPI** pour le contr√¥le d'acc√®s bas√© sur les r√¥les (RBAC).
*   **Fonctionnement :**
    1.  Cette m√©thode ne s'ex√©cute pas directement. Elle **retourne une fonction** (`role_checker`).
    2.  Cette fonction `role_checker` est celle qui est utilis√©e avec `Depends()` dans les routes.
    3.  Quand une route prot√©g√©e par un r√¥le est appel√©e :
        *   FastAPI ex√©cute `role_checker`.
        *   `role_checker` d√©pend lui-m√™me de `get_current_user` pour obtenir l'utilisateur authentifi√©.
        *   Il v√©rifie ensuite si le `user.role` est pr√©sent dans la liste `required_roles`.
        *   Si le r√¥le n'est pas autoris√©, il l√®ve une `HTTPException` `403 Forbidden` (l'utilisateur est bien authentifi√©, mais n'a pas les permissions).

---

### **Page 7 : Le C≈ìur de la S√©curit√© - `ServiceAuthenticator` & `SecurityConfig`**

#### Classe `ServiceAuthenticator` : Le Courrier Interne S√©curis√©

**R√¥le :** S√©curiser la communication **entre les microservices**. L'authentification utilisateur (JWT) prot√®ge les services des appels externes, mais ne prot√®ge pas un service d'un autre. Ce composant garantit que seul, par exemple, le `service-medical` autoris√© peut appeler une route interne du `service-auth`.

#### Analyse D√©taill√©e des M√©thodes

`__init__(self)`
*   **But :** Charger les cl√©s d'API secr√®tes pour chaque service.
*   **Fonctionnement :** Il lit les variables d'environnement (ex: `MEDICAL_SERVICE_API_KEY`) pour construire un dictionnaire mappant un nom de service √† sa cl√© secr√®te.

`verify_service_api_key(self, x_api_key: str = Header(...)) -> str`
*   **But :** Cr√©er une d√©pendance FastAPI pour prot√©ger les routes internes.
*   **Fonctionnement :**
    1.  Elle est utilis√©e dans une route qui ne doit √™tre appel√©e que par un autre service.
    2.  Elle extrait la valeur du header `X-API-Key`.
    3.  Elle v√©rifie si cette cl√© correspond √† l'une des cl√©s connues.
    4.  Si aucune cl√© ne correspond, elle l√®ve une `HTTPException` `403 Forbidden`.

`make_authenticated_request(self, ...)`
*   **But :** Fournir une m√©thode simple et standardis√©e pour qu'un service puisse en appeler un autre de mani√®re s√©curis√©e.
*   **Fonctionnement :**
    1.  Construit les headers HTTP n√©cessaires, en ajoutant automatiquement le `Content-Type` et le bon `X-API-Key` pour le service appelant.
    2.  Utilise la biblioth√®que `httpx` (une biblioth√®que de client HTTP asynchrone moderne) pour effectuer l'appel.
    3.  G√®re les diff√©rentes m√©thodes HTTP (GET, POST, etc.) et retourne la r√©ponse.

---

#### Classe `SecurityConfig` : Le Directeur de la S√©curit√©

**R√¥le :** C'est le point d'entr√©e unique pour la configuration de la s√©curit√© d'une application FastAPI. Il agit comme un orchestrateur qui assemble et active tous les autres composants de s√©curit√© (`JWTHandler`, `AuthMiddleware`, etc.).

#### Analyse D√©taill√©e des M√©thodes

`setup_security(self, app: FastAPI)`
*   **But :** Appliquer la configuration de s√©curit√© compl√®te √† une instance d'application FastAPI.
*   **Fonctionnement :**
    1.  **Configuration CORS :** Il configure le middleware `CORSMiddleware` pour d√©finir quelles origines (sites web) sont autoris√©es √† faire des requ√™tes √† l'API. C'est une mesure de s√©curit√© cruciale pour les navigateurs.
    2.  **Installation du Middleware :** Il installe le `AuthMiddleware` sur l'application (`@app.middleware("http")`). C'est cette ligne qui active la v√©rification de token sur toutes les requ√™tes entrantes.

`get_auth_dependency(self)`
*   **But :** Fournir un raccourci propre pour obtenir la d√©pendance de base d'authentification.
*   **Fonctionnement :** Retourne simplement la m√©thode `self.jwt_handler.get_current_user`. Cela permet d'√©crire `Depends(security.get_auth_dependency())` dans les routes, ce qui est plus lisible et centralis√©.

`get_role_dependency(self, required_roles: list)`
*   **But :** Fournir un raccourci pour obtenir la d√©pendance de v√©rification de r√¥le.
*   **Fonctionnement :** Retourne le r√©sultat de `self.auth_middleware.require_role(required_roles)`. Permet d'√©crire `Depends(security.get_role_dependency(["ADMIN"]))`.

---

### **Page 8 : La Bo√Æte √† Outils - `APIResponse` & `DataValidator`**

#### Classe `APIResponse` : Le Langage Commun

**R√¥le :** Standardiser la structure de toutes les r√©ponses JSON de l'API.

**Importance :**
*   **Pour le Frontend :** Les d√©veloppeurs frontend savent toujours √† quoi s'attendre. Ils peuvent √©crire du code g√©n√©rique pour g√©rer les succ√®s et les erreurs, car la structure (`success`, `message`, `data`, `errors`) est toujours la m√™me.
*   **Pour le Backend :** Fournit des m√©thodes "factory" (`success_response`, `error_response`) qui rendent le code des contr√¥leurs plus propre et plus coh√©rent.

**Fonctionnement :** C'est un mod√®le Pydantic qui d√©finit la structure de la r√©ponse. Les m√©thodes `@classmethod` sont des constructeurs alternatifs qui simplifient la cr√©ation de r√©ponses communes.

---

#### Classe `DataValidator` : Le Contr√¥leur Qualit√©

**R√¥le :** Centraliser toute la logique de validation et de nettoyage des donn√©es qui n'est pas directement li√©e √† un mod√®le de base de donn√©es.

**Importance :**
*   **S√©curit√© :** La m√©thode `sanitize_input` est cruciale pour pr√©venir les attaques par injection de code (XSS) en retirant les balises HTML/JavaScript potentiellement malveillantes.
*   **Fiabilit√© :** Valider les formats (email, t√©l√©phone) en amont garantit que seules des donn√©es propres et valides entrent dans le syst√®me.
*   **Coh√©rence :** La logique de validation de la force d'un mot de passe est la m√™me pour l'inscription et la mise √† jour, car elle est d√©finie en un seul endroit.

**Fonctionnement :** Il s'agit d'une collection de m√©thodes statiques (`@staticmethod`), ce qui signifie qu'il n'est pas n√©cessaire de cr√©er une instance de la classe pour les utiliser (`DataValidator.validate_email(...)`).

---

### **Page 9 : La Bo√Æte √† Outils - `StructuredLogger` & `ErrorHandler`**

#### Classe `StructuredLogger` : Le Journal de Bord Intelligent

**R√¥le :** Produire des logs au format JSON structur√© plut√¥t qu'en simple texte.

**B√©n√©fices :**
*   **Lisibilit√© Machine :** Les logs JSON sont facilement parsables par des syst√®mes de centralisation de logs (comme la stack ELK - Elasticsearch, Logstash, Kibana - ou Loki).
*   **Recherche et Analyse :** Il devient trivial de rechercher tous les logs d'un `user_id` sp√©cifique, ou de filtrer toutes les erreurs (`"level": "ERROR"`) d'un service donn√© (`"service": "medical-service"`).
*   **Alerting :** On peut configurer des alertes pr√©cises bas√©es sur les champs du JSON (ex: alerter si `duration_ms > 2000`).

**Fonctionnement :** Il utilise la biblioth√®que standard `logging` de Python mais la configure avec un `Formatter` personnalis√© qui force la sortie en JSON. Il propose des m√©thodes sp√©cialis√©es comme `audit` et `performance` pour standardiser les logs importants.

---

#### Classe `ErrorHandler` : Le Service des Urgences Logiciel

**R√¥le :** Intercepter toutes les exceptions non g√©r√©es dans l'application et les transformer en une r√©ponse `APIResponse` propre et standardis√©e.

**Importance :**
*   **S√©curit√© :** Emp√™che les "fuites" d'informations techniques sensibles (comme les stack traces Python) vers le client en cas d'erreur inattendue.
*   **Exp√©rience Utilisateur :** Fournit toujours une r√©ponse JSON propre, m√™me en cas d'erreur `500 Internal Server Error`, ce que les applications frontend peuvent g√©rer de mani√®re pr√©visible.

**Fonctionnement :** Il utilise les d√©corateurs `@app.exception_handler(...)` de FastAPI pour enregistrer des fonctions qui seront appel√©es sp√©cifiquement lorsqu'un certain type d'exception se produit. Il y a un handler pour les `HTTPException`, un pour les erreurs de validation de Pydantic (`RequestValidationError`), et un handler "fourre-tout" pour `Exception`.

---

### **Page 10 : La Bo√Æte √† Outils - `ConfigManager`**

#### Classe `ConfigManager` : Le Centre de Configuration

**R√¥le :** Centraliser l'acc√®s √† toutes les variables de configuration de l'application, en les chargeant depuis les fichiers `.env`.

**Importance :**
*   **Principe des 12 Facteurs :** S√©pare la configuration du code. Les informations sensibles (cl√©s d'API, URL de base de donn√©es) ne sont pas stock√©es dans le code source mais dans des fichiers `.env` (qui ne doivent pas √™tre commit sur Git).
*   **Environnements Multiples :** Permet de d√©ployer la m√™me base de code en production, en staging ou en d√©veloppement en changeant simplement le fichier `.env`.
*   **Centralisation :** √âvite d'avoir des `os.getenv(...)` dispers√©s partout dans le code.

**Fonctionnement :** C'est une classe avec des m√©thodes de classe (`@classmethod`) qui agissent comme un "singleton" de configuration. Elle utilise un cache (`_config_cache`) pour ne lire les variables d'environnement qu'une seule fois par service, am√©liorant ainsi les performances. Elle fournit des m√©thodes utilitaires (`_get_int`, `_get_bool`) pour convertir les cha√Ænes de caract√®res des variables d'environnement en types Python corrects.

---

### **Page 11 : La Fondation des Donn√©es - `BaseModel`**

#### Classe `BaseModel` : Le Plan de Construction

**R√¥le :** C'est un mod√®le de base SQLAlchemy dont tous les autres mod√®les de donn√©es (comme `Utilisateur`, `Consultation`, etc.) doivent h√©riter.

**Avantages :**
*   **Champs Communs :** D√©finit les champs que chaque table de notre base de donn√©es devrait avoir :
    *   `id` : Un identifiant unique universel (UUID), cl√© primaire.
    *   `created_at` : Un timestamp automatique enregistrant la date de cr√©ation de l'enregistrement.
    *   `updated_at` : Un timestamp qui se met √† jour automatiquement √† chaque modification de l'enregistrement.
    *   `is_active` : Un bool√©en pour la "suppression douce" (soft delete), permettant de d√©sactiver un enregistrement sans le supprimer physiquement de la base de donn√©es.
*   **Coh√©rence :** Garantit que toutes les tables de la base de donn√©es suivent la m√™me structure de base.
*   **DRY :** √âvite de red√©finir ces quatre champs dans chaque nouveau mod√®le.

**Fonctionnement :**
*   `__abstract__ = True` : Indique √† SQLAlchemy que `BaseModel` n'est pas une table √† cr√©er dans la base de donn√©es, mais un mod√®le parent abstrait.
*   `default=...` et `onupdate=...` : Ce sont des directives pour SQLAlchemy qui lui indiquent comment g√©rer automatiquement les valeurs de ces colonnes au niveau de la base de donn√©es.

---

### **Page 12 : Synth√®se et Flux de Vie d'une Requ√™te Prot√©g√©e**

Imaginons une requ√™te `POST /medical/consultations` avec un r√¥le `MEDECIN`.

1.  **R√©ception :** La requ√™te arrive sur le serveur FastAPI.
2.  **`AuthMiddleware` (`__call__`) :**
    *   La route `/medical/consultations` n'est pas dans `_is_public_route`.
    *   Le token `Bearer ...` est extrait du header.
    *   `JWTHandler.get_current_user` est appel√©. Il valide la signature et l'expiration du token et retourne un objet `TokenData` avec `role="MEDECIN"`.
    *   Les donn√©es de l'utilisateur sont stock√©es dans `request.state.user`.
    *   La requ√™te est autoris√©e √† continuer.
3.  **Routing FastAPI :** FastAPI dirige la requ√™te vers la fonction `creer_consultation`.
4.  **Injection de D√©pendances :**
    *   FastAPI voit `Depends(security.get_role_dependency(["MEDECIN"]))`.
    *   Il ex√©cute la d√©pendance `role_checker` de `AuthMiddleware`.
    *   `role_checker` r√©cup√®re l'utilisateur d√©j√† valid√© et v√©rifie que `user.role` ("MEDECIN") est bien dans la liste `["MEDECIN"]`. C'est le cas.
    *   L'objet `utilisateur` est inject√© dans la fonction.
5.  **Ex√©cution du Contr√¥leur :**
    *   Le corps de la requ√™te est valid√© par Pydantic. Une erreur ici serait intercept√©e par `ErrorHandler`.
    *   Le code de la fonction s'ex√©cute.
    *   `DataValidator.sanitize_input` peut √™tre appel√© pour nettoyer les notes m√©dicales.
    *   `StructuredLogger.info` est appel√© pour enregistrer l'action.
    *   Un nouvel objet `Consultation` (qui h√©rite de `BaseModel`) est cr√©√© et sauvegard√© en base de donn√©es.
6.  **R√©ponse :**
    *   La fonction retourne le r√©sultat en utilisant `APIResponse.created_response(...)`.
    *   La r√©ponse JSON, format√©e et coh√©rente, est envoy√©e au client.

**Conclusion :** Chaque composant de `shared_libs` a un r√¥le pr√©cis et collabore pour cr√©er un syst√®me robuste, s√©curis√© et facile √† maintenir.


---


#### **3.4. Strat√©gie de D√©couplage et de Communication Interservices**

L'architecture du syst√®me hospitalier digital adh√®re rigoureusement au mod√®le "Database-per-Service", une pratique fondamentale de l'architecture microservices qui garantit une autonomie et un d√©couplage maximum entre les composants du syst√®me.

**3.4.1. Communication Exclusive par Contrats d'API**

Toute communication entre les fronti√®res des services est r√©alis√©e de mani√®re synchrone via des appels API RESTful s√©curis√©s. Les interactions ne sont pas mod√©lis√©es par des sch√©mas de base de donn√©es distribu√©s ou des appels de proc√©dure √† distance (RPC) fortement coupl√©s. Chaque service expose un contrat d'API clair, et c'est l'unique moyen pour un service externe d'interagir avec lui. Cette approche d√©couple le cycle de vie des services : la logique interne d'un service peut √™tre enti√®rement remani√©e tant que son contrat d'API public reste stable.

**3.4.2. Absence de Persistance Partag√©e**

Conform√©ment √† cette strat√©gie, il n'existe aucune forme de couplage au niveau de la couche de persistance entre les microservices. Les points suivants sont strictement appliqu√©s :

*   **Isolation des Sch√©mas :** Chaque microservice est le seul propri√©taire de son sch√©ma de base de donn√©es. Aucune relation par cl√© √©trang√®re n'est √©tablie entre les bases de donn√©es de services distincts.
*   **Interdiction d'Acc√®s Direct :** Un service A n'est jamais autoris√© √† ex√©cuter des requ√™tes (lecture ou √©criture) directement sur la base de donn√©es du service B. Pour obtenir ou modifier une donn√©e appartenant √† B, A doit imp√©rativement passer par l'API expos√©e par B.

**3.4.3. Maximisation de la Coh√©sion Interne et Minimisation du Couplage Externe**

Le syst√®me est con√ßu pour favoriser une **forte coh√©sion interne** au sein de chaque microservice. Les classes, mod√®les et services qui constituent un microservice sont, par nature, fortement coupl√©s pour accomplir une fonctionnalit√© m√©tier coh√©rente.

Inversement, le **couplage externe** entre les microservices est minimis√© et explicitement g√©r√© via les API. Le seul point de convergence est l'utilisation de la biblioth√®que `shared_libs`, qui a pour unique vocation de standardiser les aspects transverses et non fonctionnels (s√©curit√©, observabilit√©, etc.), sans introduire de d√©pendances sur la logique m√©tier.


---

Absolument. Le texte que vous avez fourni explique une √©tape cruciale de la mise en place de l'environnement de d√©veloppement local avant l'utilisation de Docker. Voici plusieurs versions corrig√©es et am√©lior√©es, de la plus simple √† la plus d√©taill√©e, pour l'int√©grer dans votre documentation.

---


Absolument. Voici la section de documentation que vous avez fournie, enti√®rement r√©organis√©e et enrichie pour int√©grer le processus d'initialisation de la base de donn√©es avec le `DatabaseManager` et le script `init_db.py`.

Cette nouvelle version est plus pr√©cise et guide le d√©veloppeur √† travers le flux de travail correct, en insistant sur le fait que l'ORM √©crit le SQL pour lui.

---

### **3. Mise en Place de l'Environnement de D√©veloppement Local (Sans Docker)**

Cette proc√©dure documente la configuration manuelle compl√®te pour qu'un d√©veloppeur puisse ex√©cuter et tester un microservice sur sa machine locale. Elle couvre l'installation des d√©pendances, la cr√©ation de la base de donn√©es et l'initialisation du sch√©ma applicatif via l'ORM.

**Philosophie :** L'objectif est de simuler l'architecture "une base de donn√©es par service" en local, en rendant chaque d√©veloppeur responsable de l'environnement du ou des services sur lesquels il intervient.

**Processus de Configuration :**

Un d√©veloppeur ayant r√©cemment clon√© le d√©p√¥t doit suivre les √©tapes ci-dessous pour chaque microservice qu'il souhaite ex√©cuter.

---

#### **√âtape 1 : Isolation des D√©pendances**

Il est imp√©ratif d'utiliser un environnement virtuel Python pour √©viter les conflits de d√©pendances et garder un projet propre. Depuis la racine du projet :

```bash
python -m venv venv
source venv/bin/activate  # Sur Linux/macOS
# venv\Scripts\activate    # Sur Windows
```

---

#### **√âtape 2 : Installation des D√©pendances Sp√©cifiques au Service**

Chaque microservice est autonome et d√©clare ses propres d√©pendances dans un fichier `requirements.txt`. Le d√©veloppeur doit se positionner dans le r√©pertoire du service cible et ex√©cuter l'installation.

*Exemple pour `service-medical` :*
```bash
cd service-medical/
pip install -r requirements.txt
```
Cette commande n'installera que les biblioth√®ques n√©cessaires au fonctionnement du service m√©dical.

---

#### **√âtape 3 : Pr√©paration et Initialisation de la Base de Donn√©es**

Cette √©tape cruciale se d√©roule en trois temps : la cr√©ation manuelle d'une base de donn√©es **vide**, la configuration de la connexion, et la cr√©ation **automatis√©e** des tables par l'ORM.

**3.1. Cr√©ation de la Base de Donn√©es Vide (Op√©ration Manuelle)**

C'est la **seule action SQL manuelle** que vous aurez √† faire. Connectez-vous √† votre instance PostgreSQL et cr√©ez une base de donn√©es vide ainsi qu'un utilisateur d√©di√© pour le service.

*Exemple de commandes SQL pour `service-medical` :*
```sql
CREATE DATABASE hospital_medical_db;
CREATE USER medical_user WITH PASSWORD 'un_mot_de_passe_securise';
GRANT ALL PRIVILEGES ON DATABASE hospital_medical_db TO medical_user;
```

**3.2. Configuration de la Connexion (`.env`)**

√Ä la racine du dossier de votre service (ex: dans `service-medical/`), cr√©ez un fichier nomm√© `.env`. Ce fichier indiquera √† votre application comment se connecter √† la base de donn√©es que vous venez de cr√©er.

*Contenu du fichier `/service-medical/.env` :*```
DATABASE_URL="postgresql://medical_user:un_mot_de_passe_securise@localhost:5432/hospital_medical_db"
JWT_SECRET_KEY="une_cle_secrete_pour_le_developpement"
```

**3.3. Cr√©ation Automatis√©e des Tables (via le Script `init_db.py`)**

Maintenant que la base de donn√©es vide existe et que l'application sait s'y connecter, nous allons demander √† l'ORM SQLAlchemy de cr√©er les tables pour nous. **Vous n'√©crirez jamais `CREATE TABLE` manuellement.**

*   **Comment √ßa marche ?** Le script `init_db.py` (√† cr√©er si besoin dans le dossier `src/` du service) importe vos mod√®les Python (ex: `Consultation`, `DossierMedical`). L'ORM analyse ces classes et g√©n√®re automatiquement le code SQL pour cr√©er les tables correspondantes.

*   **Ex√©cutez le script** depuis la **racine du projet** (`projet-hospitalier/`) :
    ```bash
    python service-medical/src/init_db.py
    ```

*   **R√©sultat :** Apr√®s l'ex√©cution du script, votre base de donn√©es `hospital_medical_db` contiendra toutes les tables n√©cessaires (`consultations`, `dossiers_medicaux`, etc.), cr√©√©es avec les bonnes colonnes et les bons types, sans que vous ayez √©crit une seule ligne de SQL.

*(Note : vous trouverez un template pour le script `init_db.py` dans la documentation d√©taill√©e de l'architecture.)*

---

#### **√âtape 4 : Lancement du Service**

Votre environnement est maintenant pr√™t : les d√©pendances sont install√©es et la base de donn√©es est initialis√©e. Vous pouvez lancer le serveur web.

Pour que les importations depuis `shared_libs` fonctionnent, il est essentiel de configurer le `PYTHONPATH`. L'ex√©cution se fait depuis le r√©pertoire `src` du service.

```bash
cd service-medical/src/
PYTHONPATH=../../ python3 main.py
```

Le service devrait maintenant d√©marrer sans erreur et √™tre accessible, par exemple, sur `http://localhost:8003`. Il est connect√© √† une base de donn√©es locale, propre et enti√®rement initialis√©e.
